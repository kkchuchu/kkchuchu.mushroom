[[with]] open('/path/to/some/file/you/want/to/read') as file_1, \
     open('/path/to/some/file/being/written', 'w') as file_2:
    file_2.write(file_1.read())
    
answer = ('Ten for that? You must be mad!'
          if does_not_haggle(brian)
          else "It's worth ten if it's worth a shekel.")
          
'{} {}'.format('one', 'two')
data = {'first': 'Hodor', 'last': 'Hodor!'}
'{first} {last}'.format(**data)

The %s specifier converts the object using str(), and %r converts it using repr().
import datetime

d = datetime.date.today()
str(d)
'2011-05-14'
repr(d)
'datetime.date(2011, 5, 14)'

=== mock ===
a.py
    -> Defines SomeClass

b.py
    -> from a import SomeClass
    -> some_function instantiates SomeClass
    
Now we want to test some_function but we want to mock out SomeClass using patch(). 
The problem is that when we import module b, which we will have to do then it imports SomeClass from module a. 
If we use patch() to mock out a.SomeClass then it will have no effect on our test; module b already has a reference to the real SomeClass and it looks like our patching had no effect.

The key is to patch out SomeClass where it is used (or where it is looked up ). 
In this case some_function will actually look up SomeClass in module b, where we have imported it. The patching should look like:
@patch('b.SomeClass')

=== json indent ===
print json.dumps(parsed, indent=4, sort_keys=True)
